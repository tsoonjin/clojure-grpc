;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package com.example.addressbook
;;;----------------------------------------------------------------------------------
(ns com.example.addressbook
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :as serdes.core]
            [protojure.protobuf.serdes.complex :as serdes.complex]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as serdes.stream]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->Person)
(declare ecis->Person)
(declare new-Person)
(declare cis->AddressBook)
(declare ecis->AddressBook)
(declare new-AddressBook)
(declare cis->HelloResponse)
(declare ecis->HelloResponse)
(declare new-HelloResponse)


;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; Person
;-----------------------------------------------------------------------------
(defrecord Person-record [name]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:name this) os))
  pb/TypeReflection
  (gettype [this]
    "com.example.addressbook.Person"))

(s/def :com.example.addressbook.Person/name string?)
(s/def ::Person-spec (s/keys :opt-un [:com.example.addressbook.Person/name ]))
(def Person-defaults {:name "" })

(defn cis->Person
  "CodedInputStream to Person"
  [is]
  (->> (tag-map Person-defaults
         (fn [tag index]
             (case index
               1 [:name (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Person-record)))

(defn ecis->Person
  "Embedded CodedInputStream to Person"
  [is]
  (serdes.core/cis->embedded cis->Person is))

(defn new-Person
  "Creates a new instance from a map, similar to map->Person except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Person-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Person-spec init))))]}
  (-> (merge Person-defaults init)
      (map->Person-record)))

(defn pb->Person
  "Protobuf to Person"
  [input]
  (cis->Person (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Person-meta {:type "com.example.addressbook.Person" :decoder pb->Person})

;-----------------------------------------------------------------------------
; AddressBook
;-----------------------------------------------------------------------------
(defrecord AddressBook-record [people]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:people this) os))
  pb/TypeReflection
  (gettype [this]
    "com.example.addressbook.AddressBook"))

(s/def ::AddressBook-spec (s/keys :opt-un []))
(def AddressBook-defaults {:people [] })

(defn cis->AddressBook
  "CodedInputStream to AddressBook"
  [is]
  (->> (tag-map AddressBook-defaults
         (fn [tag index]
             (case index
               1 [:people (serdes.complex/cis->repeated ecis->Person is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->AddressBook-record)))

(defn ecis->AddressBook
  "Embedded CodedInputStream to AddressBook"
  [is]
  (serdes.core/cis->embedded cis->AddressBook is))

(defn new-AddressBook
  "Creates a new instance from a map, similar to map->AddressBook except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AddressBook-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AddressBook-spec init))))]}
  (-> (merge AddressBook-defaults init)
      (cond-> (some? (get init :people)) (update :people #(map new-Person %)))
      (map->AddressBook-record)))

(defn pb->AddressBook
  "Protobuf to AddressBook"
  [input]
  (cis->AddressBook (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record AddressBook-meta {:type "com.example.addressbook.AddressBook" :decoder pb->AddressBook})

;-----------------------------------------------------------------------------
; HelloResponse
;-----------------------------------------------------------------------------
(defrecord HelloResponse-record [message]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:message this) os))
  pb/TypeReflection
  (gettype [this]
    "com.example.addressbook.HelloResponse"))

(s/def :com.example.addressbook.HelloResponse/message string?)
(s/def ::HelloResponse-spec (s/keys :opt-un [:com.example.addressbook.HelloResponse/message ]))
(def HelloResponse-defaults {:message "" })

(defn cis->HelloResponse
  "CodedInputStream to HelloResponse"
  [is]
  (->> (tag-map HelloResponse-defaults
         (fn [tag index]
             (case index
               1 [:message (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->HelloResponse-record)))

(defn ecis->HelloResponse
  "Embedded CodedInputStream to HelloResponse"
  [is]
  (serdes.core/cis->embedded cis->HelloResponse is))

(defn new-HelloResponse
  "Creates a new instance from a map, similar to map->HelloResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::HelloResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::HelloResponse-spec init))))]}
  (-> (merge HelloResponse-defaults init)
      (map->HelloResponse-record)))

(defn pb->HelloResponse
  "Protobuf to HelloResponse"
  [input]
  (cis->HelloResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record HelloResponse-meta {:type "com.example.addressbook.HelloResponse" :decoder pb->HelloResponse})

